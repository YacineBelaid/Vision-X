/*! For license information please see 662.js.LICENSE.txt */
(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[662],{1719:(e,t,o)=>{"use strict";o.r(t),o.d(t,{default:()=>$});var s=o(97542),a=o(89570),r=o(35221),d=o(5823),n=o(80742),i=o(38399),l=o(71166),h=o(56163),c=o(76957);class u extends h.K{constructor(e,t,o,s){super(e,t),this.room=o,this.id=this.room.id,this.title=this.room.name,this.icon="icon-edit-floorplan",this.typeId=d.SF.MODELROOM,this.layerId=n.g,this.dateBucket=r.Z.OLDER,this.enabled=!0,this.floorId=s}}function g(e){const t=e.map((e=>[e.x,e.z]));return t.push(t[0]),function(e,t=!1){let o=0;for(let t=0,s=e.length;t<s;t++){const a=e[t],r=e[t===s-1?0:t+1];o+=a[0]*r[1],o-=r[0]*a[1]}return t?o/2:Math.abs(o/2)}(t)}class f{constructor(e,t,o,s){this.id=e,this.name=t,this.points=o,this.walls=s}get floorIndex(){return this.points[0].floorIndex}getSnapshot(){return{height:0,lowerElevation:0,source:"frontend",vertices:this.points.map((e=>e.id))}}getArea(){return g(this.points)}}var w=o(92558),p=o(84428);class m{constructor(e,t,o,s){this._t1=new p.Vector3,this._t2=new p.Vector3,this.id=e,this.from=t,this.to=o,this.width=s}static getCompositeKey(e,t){const o=[e,t].sort();return`${o[0]}:${o[1]}`}get floorIndex(){return this.from.floorIndex}getOtherNode(e){if(e===this.from)return this.to;if(e===this.to)return this.from;throw new Error(`WallNode id: ${e.id} does not belong to edge id: ${this.id}`)}hasNodes(e,t){const{from:o,to:s}=this;return!(e!==o&&e!==s||t!==o&&t!==s)}getVec3(e){const t=e||new p.Vector3;return t.set(this.to.x-this.from.x,0,this.to.z-this.from.z),t}getProjection(e){const t=this._t1.copy(e).sub(this.from.getVec3(this._t2)),o=this.getVec3(this._t2);return t.dot(o)/o.length()}getSnapshot(){return{thickness:this.width}}get length(){const e=this.from.x-this.to.x,t=this.from.z-this.to.z;return Math.sqrt(e*e+t*t)}}class _{constructor(e,t,o,s){this.id=e,this.floorIndex=t,this.x=o,this.z=s}getPoint(){return{x:this.x,z:this.z}}getVec3(e){const t=e||new p.Vector3;return t.set(this.x,0,this.z),t}getSnapshot(){return{x:this.x,y:-this.z}}}class v{constructor(e,t){this.data=e,this.inputs=t,this._outputCache=null}onRun(e){throw new Error("Method not implemented.")}onInvert(e,t){throw new Error("Method not implemented.")}run(){this._outputCache=this.onRun(this.inputs)}invert(){if(!this._outputCache)throw new Error("Attempted to inverse a data action before running it");this.onInvert(this._outputCache,this.inputs),this._outputCache=null}merge(e){return!1}get output(){if(this._outputCache)return this._outputCache;throw new Error("Tried to read output of an action before it was run")}}class W extends v{onRun(e){const t=this.data.getNode(e.nodeId),o={x:t.x,z:t.z};return this.data._updateNode(e.nodeId,e.newPos),this.data._updateWallForNodes(t),{prevPos:o}}onInvert(e,t){this.data._updateNode(t.nodeId,e.prevPos);const o=this.data.getNode(t.nodeId);this.data._updateWallForNodes(o)}merge(e){return e instanceof W&&e.inputs.nodeId===this.inputs.nodeId&&(this.inputs.newPos=e.inputs.newPos,!0)}}class I extends v{onRun(e){const t=this.data._createNode(e.from,e.floorIndex),o=this.data._createNode(e.to,e.floorIndex),s=this.data._createWall(t,o,e.width);return{fromId:t.id,toId:o.id,wall:s.id}}onInvert(e,t){this.data._deleteWall(e.wall),this.data._deleteNode(e.fromId),this.data._deleteNode(e.toId)}merge(e){return!!(e instanceof W&&this._outputCache&&e.inputs.nodeId===this._outputCache.toId)&&(this.inputs.to=e.inputs.newPos,!0)}}var b=o(83021);class N{constructor(){this.actions=[]}run(){for(const e of this.actions)e.run()}invert(){for(let e=this.actions.length-1;e>=0;e--){const t=this.actions[e];null==t||t.invert()}}merge(e){if(0===this.actions.length)this.actions.push(e);else{const t=this.actions[this.actions.length-1];t&&t.merge(e)||this.actions.push(e)}return!0}}class x{constructor(){this.undoBuffer=new b.P(50),this.finalized=!1}push(e){(this.undoBuffer.isEmpty()||this.finalized)&&(this.undoBuffer.push(new N),this.finalized=!1);const t=this.undoBuffer.peek();t&&t.merge(e)}pop(){return this.undoBuffer.pop()}finalize(){this.finalized=!0}availableUndos(){return this.undoBuffer.count}}var y=o(35895),O=o(97998);class R extends v{onRun(e){const t=this.data.getWall(e.wallId),o=t.from.getPoint(),s=t.to.getPoint();return this.data._updateNode(t.from.id,e.newFromPos),this.data._updateNode(t.to.id,e.newToPos),this.data._updateWallForNodes(t.from,t.to),{prevFromPos:o,prevToPos:s}}onInvert(e,t){const o=this.data.getWall(t.wallId);this.data._updateNode(o.from.id,e.prevFromPos),this.data._updateNode(o.to.id,e.prevToPos),this.data._updateWallForNodes(o.from,o.to)}merge(e){return e instanceof R&&e.inputs.wallId===this.inputs.wallId&&(this.inputs.newFromPos=e.inputs.newFromPos,this.inputs.newToPos=e.inputs.newToPos,!0)}}class C extends v{onRun(e){const t=this.data.getNode(e.fromId),o=this.data._createNode(e.to,t.floorIndex),s=this.data._createWall(t,o,e.width);return{toId:o.id,wall:s.id}}onInvert(e,t){this.data._deleteWall(e.wall),this.data._deleteNode(e.toId)}merge(e){return!!(e instanceof W&&this._outputCache&&e.inputs.nodeId===this._outputCache.toId)&&(this.inputs.to=e.inputs.newPos,!0)}}class P extends v{onRun(e){const t=this.data.getNode(e.mergeId),o=this.data.getNode(e.keepId),s=o.getPoint();this.data._updateNode(o.id,t.getPoint());const a=this.data.getWallsForNode(t),r=[];for(const e of a){const s=e.getOtherNode(t),a=e.width;this.data._deleteWall(e.id);let d=null;this.needsReplacementWall(e,t,o)&&(d=this.data._createWall(s,o,a)),r.push({deleted:e,created:d})}return this.data._deleteNode(t.id),this.data._updateWallForNodes(t,o),{deletedNode:t,wallDiff:r,oldKeepNodePos:s}}onInvert(e,t){const o=e.deletedNode,s=this.data._createNode(o.getPoint(),o.floorIndex,o.id);for(const t of e.wallDiff)t.created&&this.data._deleteWall(t.created.id),this.data._createWall(s,t.deleted.getOtherNode(e.deletedNode),t.deleted.width);this.data._updateNode(t.keepId,e.oldKeepNodePos),this.data._updateWallForNodes(s,this.data.getNode(t.keepId))}needsReplacementWall(e,t,o){const s=e.getOtherNode(t);if(s===o)return!1;const a=m.getCompositeKey(s.id,o.id);return!this.data.walls.has(a)}}class z extends v{onRun(e){const t=this.data.getWall(e.wallId),o=this.data.getEdgeCountForNode(t.from),s=this.data.getEdgeCountForNode(t.to);let a="none";return 1===o&&1===s?(a="both",this.data._deleteNode(t.from.id),this.data._deleteNode(t.to.id)):1===o?(a="from",this.data._deleteNode(t.from.id)):1===s?(a="to",this.data._deleteNode(t.to.id)):a="none",this.data._deleteWall(e.wallId),{deletedWall:t,deletedNodes:a}}onInvert(e,t){const o=e.deletedWall;let s,a;switch(e.deletedNodes){case"both":s=this.data._createNode({x:o.from.x,z:o.from.z},o.floorIndex,o.from.id),a=this.data._createNode({x:o.to.x,z:o.to.z},o.floorIndex,o.to.id),this.data._createWall(s,a,o.width);break;case"none":this.data._createWall(o.from,o.to,o.width);break;case"from":s=this.data._createNode({x:o.from.x,z:o.from.z},o.floorIndex,o.from.id),this.data._createWall(s,o.to,o.width);break;case"to":a=this.data._createNode({x:o.to.x,z:o.to.z},o.floorIndex,o.to.id),this.data._createWall(o.from,a,o.width);break;default:throw new Error(`${e.deletedNodes} is an invalid value`)}}}class E extends v{onRun(e){const t=this.data.getWall(e.fromWallId),o=t.getVec3().normalize().multiplyScalar(e.along),s=t.from.getVec3().add(o);this.data._deleteWall(e.fromWallId);const a=this.data._createNode({x:s.x,z:s.z},t.floorIndex),r=this.data._createNode(e.to,t.floorIndex);return{deletedWall:t,newTrailingWall:this.data._createWall(a,r,e.width),newLeftWall:this.data._createWall(t.from,a,t.width),newRightWall:this.data._createWall(a,t.to,t.width)}}onInvert(e,t){this.data._deleteWall(e.newTrailingWall.id),this.data._deleteWall(e.newLeftWall.id),this.data._deleteWall(e.newRightWall.id),this.data._deleteNode(e.newTrailingWall.from.id),this.data._deleteNode(e.newTrailingWall.to.id),this.data._createWall(e.deletedWall.from,e.deletedWall.to,e.deletedWall.width)}merge(e){return!!(e instanceof W&&this._outputCache&&e.inputs.nodeId===this._outputCache.newTrailingWall.to.id)&&(this.inputs.to=e.inputs.newPos,!0)}}class T extends v{onRun(e){const t=this.data.getWall(e.wallId),o=this.data.getNode(e.nodeId),s={x:o.x,z:o.z},a=t.getVec3().normalize().multiplyScalar(e.along),r=t.from.getVec3().add(a);this.data._deleteWall(t.id),this.data._updateNode(e.nodeId,{x:r.x,z:r.z}),this.data._updateWallForNodes(o);return{deletedWall:t,newLeftWall:this.data.hasWallBetween(t.from,o)?null:this.data._createWall(t.from,o,t.width),newRightWall:this.data.hasWallBetween(o,t.to)?null:this.data._createWall(o,t.to,t.width),prevNodePos:s}}onInvert(e,t){e.newLeftWall&&this.data._deleteWall(e.newLeftWall.id),e.newRightWall&&this.data._deleteWall(e.newRightWall.id),this.data._updateNode(t.nodeId,e.prevNodePos),this.data._updateWallForNodes(this.data.getNode(t.nodeId)),this.data._createWall(e.deletedWall.from,e.deletedWall.to,e.deletedWall.width)}}class F extends v{onRun(e){const t=this.data.getWall(e.wallId).width;return this.data._setWidth(e.wallId,e.width),{width:t,wallId:e.wallId}}onInvert(e,t){this.data._setWidth(e.wallId,e.width)}merge(e){return e instanceof F&&e.inputs.wallId===this.inputs.wallId&&(this.inputs.width=e.inputs.width,!0)}}function M(e,t){let o,s,a=t[t.length-1],r=0;for(let d=0;d<t.length;++d)o=a,a=t[d],o.y<=e.y&&a.y<=e.y||o.y>e.y&&a.y>e.y||o.x<e.x&&a.x<e.x||(s=(e.y-o.y)*(a.x-o.x)-(e.x-o.x)*(a.y-o.y),a.y<o.y&&(s=-s),r+=s>0?1:0);return r%2==1}function A(e,t){return e.size===t.size&&[...e].every((e=>t.has(e)))}class S extends v{onRun(e){const{id:t,name:o}=e,s=this.data.getRoom(t).name;return this.data._setRoomDetails(t,o),{id:t,name:s}}onInvert(e,t){const{id:o,name:s}=e;this.data._setRoomDetails(o,s)}}class B extends v{onRun(e){const t=this.data.getWall(e.wallId),o=[],s=[],a=[],r={originalFromPos:t.from.getPoint(),originalToPos:t.to.getPoint(),deletedWalls:s,createdWalls:o,originalWallId:e.wallId,createdNodes:a};return e.fromNode&&this.createJoint(t.from,t,s,o,a),e.toNode&&this.createJoint(t.to,t,s,o,a),r}onInvert(e,t){for(const t of e.createdWalls)this.data._deleteWall(t.id);for(const t of e.deletedWalls)this.data._createWall(t.from,t.to,t.width);for(const t of e.createdNodes)this.data._deleteNode(t.id);const o=this.data.getWall(this.inputs.wallId);this.data._updateNode(o.from.id,e.originalFromPos),this.data._updateNode(o.to.id,e.originalToPos),this.data._updateWallForNodes(o.from,o.to)}merge(e){return e instanceof R&&e.inputs.wallId===this.inputs.wallId&&(this.inputs.fromPos=e.inputs.newFromPos,this.inputs.toPos=e.inputs.newToPos,!0)}createJoint(e,t,o,s,a){const r=this.data._createNode({x:e.x,z:e.z},e.floorIndex),d=this.data.getWallsForNode(e);for(const a of d)if(a.id!==t.id){const t=a.getOtherNode(e);o.push(a),this.data._deleteWall(a.id);const d=a.from===t?this.data._createWall(t,r,a.width):this.data._createWall(r,t,a.width);s.push(d)}a.push(r);const n=t.from===e?this.data._createWall(r,t.from,t.width):this.data._createWall(t.to,r,t.width);s.push(n)}}class k{constructor(){this.data=new Map,this.addedObservers=new Set,this.updatedObservers=new Set,this.deletedObservers=new Set}clear(){this.data.clear()}get(e){return this.data.get(e)}set(e,t){this.data.set(e,t)}delete(e){this.data.delete(e)}has(e){return this.data.has(e)}onChanged(e){return(0,y.k1)((()=>{e.onAdded&&this.addedObservers.add(e.onAdded),e.onUpdated&&this.updatedObservers.add(e.onUpdated),e.onRemoved&&this.deletedObservers.add(e.onRemoved)}),(()=>{e.onAdded&&this.addedObservers.delete(e.onAdded),e.onUpdated&&this.updatedObservers.delete(e.onUpdated),e.onRemoved&&this.deletedObservers.delete(e.onRemoved)}),!0)}}class V{constructor(e){this.name="wall-graph",this.version=0,this._nodes=new k,this._walls=new k,this._rooms=new k,this.undoBuffer=new x,this._nodeToWallMap=new Map,this._wallToRoomMap=new Map,this._observerQueue=[],this._anythingChangeObservers=new Set,this.logger=new O.Z("wall-graph"),this.wallsChanged=!1,this._updateWallForNodes=(()=>{const e=new Set,t=new Set;return(...o)=>{e.clear(),t.clear();for(const s of o){const o=this._nodeToWallMap.get(s);if(null!=o)for(const s of o)if(!e.has(s)){this._scheduleObserver({observers:this._walls.updatedObservers,param:s});const o=this._wallToRoomMap.get(s);if(o)for(const e of o.values())t.has(e)||(this._scheduleObserver({observers:this._rooms.updatedObservers,param:e}),t.add(e));e.add(s)}}}})(),this.getRelativeAngle=(()=>{const e=new p.Vector2,t=new p.Vector2,o=new p.Vector2,s=(t,o)=>{if(0===t.lengthSq()){const s=this.getNodeNeighbors(o);if(0===s.size)return;const a=Array.from(s.values())[0];t.set(a.x,a.z).sub(e)}};return(a,r,d)=>{if(r===d)return 2*Math.PI;e.set(a.x,a.z),t.set(r.x,r.z).sub(e),s(t,r),o.set(d.x,d.z).sub(e),s(o,d);const n=Math.atan2(t.y,t.x);let i=-(Math.atan2(o.y,o.x)-n);return i<0&&(i+=2*Math.PI),i}})(),e&&(this.version=e.version,this.load(e))}load(e){for(const t in e.floors){const o=e.floors[t],s=o.vertices;for(const e in s){const o=s[e];this._createNode({x:o.x,z:-o.y},parseInt(t,10),e)}for(const e in o.edges){const[t,s]=e.split(":"),a=o.edges[e].thickness,r=this.getNode(t),d=this.getNode(s);this._createWall(r,d,a)}}this.updateRooms()}get walls(){return this._walls.data}get nodes(){return this._nodes.data}get rooms(){return this._rooms.data}getNode(e){const t=this._nodes.get(e);if(t)return t;throw new Error("WallNode does not exist in WallGraphData")}getWall(e){const t=this._walls.get(e);if(t)return t;throw new Error("Wall does not exist in WallGraphData")}getRoom(e){const t=this._rooms.get(e);if(!t)throw new Error("Room id is invalid!");return t}isEdge(e){return this.getEntity(e)instanceof m}getEntity(e){const t=this._walls.get(e)||this._nodes.get(e)||this._rooms.get(e);if(!t)throw new Error("No wall or edge for id.");return t}getEdgeCountForNode(e){var t;return(null===(t=this._nodeToWallMap.get(e))||void 0===t?void 0:t.size)||0}getWallsForNode(e){const t=this._nodeToWallMap.get(e);if(t&&t.size>0)return t;throw new Error(`WallNode: ${e.id} has no associate walls, this should not happen unless inside an action`)}hasWallBetween(e,t){const o=m.getCompositeKey(e.id,t.id);return this._walls.has(o)}undo(){const e=this.undoBuffer.pop();e&&(this.wallsChanged=!1,e.invert(),this.wallsChanged&&this.updateRooms(),this.commit())}availableUndos(){return this.undoBuffer.availableUndos()}finalizeHistory(){this.undoBuffer.finalize()}triggerAction(e){try{this.wallsChanged=!1,e.run(),this.wallsChanged&&this.updateRooms()}catch(e){return this.logger.error(e),void(this._observerQueue.length=0)}this.undoBuffer.push(e),this.commit()}onNodesChanged(e){return this._nodes.onChanged(e)}onWallsChanged(e){return this._walls.onChanged(e)}onRoomsChanged(e){return this._rooms.onChanged(e)}commit(){const e=this._observerQueue.length;if(this._flushObserverQueue(),e>0)for(const e of this._anythingChangeObservers)e(void 0)}onPropertyChanged(e,t){const o=this["_"+e];if(o instanceof k){const s=o,a=()=>{s.addedObservers.add(t),s.updatedObservers.add(t),s.deletedObservers.add(t)},r=()=>this.removeOnPropertyChanged(e,t);return(0,y.k1)(a,r,!0,e)}throw new Error(`Property: ${e} does not exist on wall-data`)}removeOnPropertyChanged(e,t){const o=this["_"+e];if(!(o instanceof k))throw new Error(`Property: ${e} does not exist on wall-data`);{const e=o;e.addedObservers.delete(t),e.updatedObservers.delete(t),e.deletedObservers.delete(t)}}onChanged(e){if(this._anythingChangeObservers.has(e))throw new Error("This observer function is already observing this Observable, and double subscriptions are not supported.");return(0,y.k1)((()=>this._anythingChangeObservers.add(e)),(()=>this.removeOnChanged(e)),!0)}removeOnChanged(e){this._anythingChangeObservers.delete(e)}addFloatingEdge(e,t,o,s){const a=new I(this,{from:e,to:t,width:o,floorIndex:s});return this.triggerAction(a),a.output}addTrailingEdgeToNode(e,t,o){const s=new C(this,{fromId:e,to:t,width:o});return this.triggerAction(s),s.output}addTrailingEdgeToEdge(e,t,o,s){const a=new E(this,{fromWallId:e,along:t,to:o,width:s});return this.triggerAction(a),a.output}splitEdgeWithNode(e,t,o){const s=new T(this,{wallId:e,nodeId:t,along:o});return this.triggerAction(s),s.output}moveNode(e,t){const o={nodeId:e,newPos:t};this.triggerAction(new W(this,o))}moveWall(e,t,o){const s={wallId:e,newFromPos:t,newToPos:o};this.triggerAction(new R(this,s))}mergeNodes(e,t){const o=new P(this,{keepId:e,mergeId:t});return this.triggerAction(o),o.output}deleteEdge(e){const t={wallId:e};this.triggerAction(new z(this,t))}setWidth(e,t){const o={wallId:e,width:t};this.triggerAction(new F(this,o))}editRoomDetails(e,t){this.triggerAction(new S(this,{id:e,name:t}))}addWallJoint(e,t,o){const s={wallId:e,fromNode:t,toNode:o};this.triggerAction(new B(this,s))}_createNode(e,t,o){const s=new _(o||(0,w.fV)(),t,e.x,e.z);return this._nodes.set(s.id,s),this._scheduleObserver({observers:this._nodes.addedObservers,param:s}),s}_updateNode(e,t){const o=this._nodes.get(e);if(!o)throw new Error("Attempted to update WallNode that does not exist");o.x=t.x,o.z=t.z,this._scheduleObserver({observers:this._nodes.updatedObservers,param:o})}_deleteNode(e){const t=this._nodes.get(e);if(!t)throw new Error("Attempted to delete WallNode that does not exist");this._nodes.delete(e),this._scheduleObserver({observers:this._nodes.deletedObservers,param:t})}_createWall(e,t,o){if(e.id===t.id)throw new Error("Cannot create wall where the from node is the same as the to node.");if(e.floorIndex!==t.floorIndex)throw new Error("Cannot create a wall between nodes on different floors.");const s=m.getCompositeKey(e.id,t.id);if(this._walls.has(s))throw new Error(`Wall already exists between ${e.id}:${t.id}`);const a=new m(s,e,t,o);return this._walls.set(a.id,a),this._addToNodeWallMap(a),this._scheduleObserver({observers:this._walls.addedObservers,param:a}),this.wallsChanged=!0,a}_deleteWall(e){const t=this.getWall(e);this._walls.delete(e),this._removeFromNodeWallMap(t),this._scheduleObserver({observers:this._walls.deletedObservers,param:t}),this.wallsChanged=!0}_setWidth(e,t){const o=this.getWall(e);o.width=t,this._scheduleObserver({observers:this._walls.updatedObservers,param:o})}_setRoomDetails(e,t){const o=this.getRoom(e);o.name=t,this._scheduleObserver({observers:this._rooms.updatedObservers,param:o})}_addToNodeWallMap(e){const t=t=>{let o=this._nodeToWallMap.get(t);null!=o?o.add(e):(o=new Set,o.add(e),this._nodeToWallMap.set(t,o))};t(e.from),t(e.to)}_removeFromNodeWallMap(e){const t=t=>{const o=this._nodeToWallMap.get(t);null!=o&&(o.delete(e),0===o.size&&this._nodeToWallMap.delete(t))};t(e.from),t(e.to)}_scheduleObserver(e){this._observerQueue.push(e)}_flushObserverQueue(){for(const e of this._observerQueue)for(const t of e.observers){const o=e.param;t(o,o.id)}this._observerQueue.length=0}getSnapshot(){const e={version:this.version,floors:{}},t=t=>{e.floors[`${t}`]||(e.floors[`${t}`]={edges:{},vertices:{},rooms:{}})};for(const[o,s]of this._nodes.data){t(s.floorIndex);e.floors[`${s.floorIndex}`].vertices[s.id]=s.getSnapshot()}for(const[o,s]of this._walls.data){t(s.floorIndex);e.floors[`${s.floorIndex}`].edges[s.id]=s.getSnapshot()}for(const[o,s]of this._rooms.data){t(s.floorIndex);e.floors[`${s.floorIndex}`].rooms[s.id]=s.getSnapshot()}return e}updateRooms(){const e=this.findEnclosedRegions(),t=e.map((e=>new Set(e))),o=new Array;for(const e of this._rooms.data.values())for(let s=0;s<t.length;s++){const a=t[s],r=e.points.reduce(((e,t)=>a.has(t)?e+1:e),0);r>0&&o.push({score:r/e.points.length,oldRoomId:e.id,newRoomIndex:s})}const s=new Set,a=new Array(e.length);o.sort(((e,t)=>{var o,s;return t.score-e.score||((null===(o=this._rooms.get(t.oldRoomId))||void 0===o?void 0:o.getArea())||0)-((null===(s=this._rooms.get(e.oldRoomId))||void 0===s?void 0:s.getArea())||0)}));for(const{oldRoomId:e,newRoomIndex:t}of o)s.has(e)||a[t]||(a[t]=e,s.add(e));for(let t=0;t<e.length;t++)a[t]||(a[t]=(0,w.fV)());for(let t=0;t<e.length;t++){const o=a[t],s=e[t],r=new Set;for(let e=0;e<s.length;e++){const t=s[e],o=s[(e+1)%s.length];this.getWallsForNodes(r,t,o)}const d=new f(o,`Room ${o}`,e[t],r),n=this._rooms.get(o);n?A(n.walls,d.walls)||(this.rooms.set(o,d),this._scheduleObserver({observers:this._rooms.updatedObservers,param:d})):(this._rooms.set(o,d),this._scheduleObserver({observers:this._rooms.addedObservers,param:d}))}this._wallToRoomMap.clear();const r=new Set(a);for(const e of this._rooms.data.values())r.has(e.id)||(this._rooms.delete(e.id),this._scheduleObserver({observers:this._rooms.deletedObservers,param:e}));for(const e of this._rooms.data.values())for(const t of e.walls.values()){const o=this._wallToRoomMap.get(t)||new Set;o.add(e),this._wallToRoomMap.set(t,o)}this.wallsChanged=!1}findEnclosedRegions(){const e=new Array,t=new Set,o=(o,s)=>{const a=`${o.id}/${s.id}`;if(t.has(a))return;const r=[o,s];for(;;){const e=r[r.length-1],t=r[r.length-2],o=this.getNodeNeighbors(e);let s,a=4*Math.PI;for(const r of o){const o=this.getRelativeAngle(e,t,r);o<a&&(a=o,s=r)}if(!s)throw new Error("Expected a neighbor");if(e===r[0]&&s===r[1]){r.pop();break}r.push(s)}e.push(r);for(let e=0;e<r.length;e++){const o=r[e],s=r[(e+1)%r.length],a=`${o.id}/${s.id}`;t.add(a)}};for(const e of this.walls.values())o(e.from,e.to),o(e.to,e.from);const s=new Map;for(const t of e)s.set(t,g(t));e.sort(((e,t)=>s.get(e)-s.get(t)));const a=e.map((e=>e.map((e=>new p.Vector2(e.x,e.z))))),r=new p.Vector2,d=new p.Vector2;for(let t=a.length-1;t>=0;t--){const o=a[t];let s=!1;for(let n=0;n<t&&!s;n++){const i=a[n];if(i.length<3)continue;let l=!0;for(let e=0;e<i.length&&l;e++){const t=(e+1)%i.length,o=e,s=(e+2)%i.length;r.copy(i[t]),d.addVectors(i[t],i[o]).add(i[s]).multiplyScalar(1/3),d.sub(r),d.normalize().multiplyScalar(.01),r.add(d),l=!M(r,i)}l||M(r,o)&&(e.splice(t,1),s=!0)}}return e}getNodeNeighbors(e){const t=new Set,o=this._nodeToWallMap.get(e);if(!o)throw new Error("Expecting node to wall map to be valid");for(const s of o.values())t.add(s.getOtherNode(e));return t}getWallsForNodes(e,t,o){const s=m.getCompositeKey(t.id,o.id);e.add(this.getWall(s))}}class D extends s.Y{constructor(){super(...arguments),this.name="roombounds"}async init(e,t){this.data=new V,t.market.register(this,V,this.data),async function(e,t){const[o,s]=await Promise.all([e.market.waitForData(n.R),e.market.waitForData(c.i)]),r=(a,r,d=[])=>{const n=[];for(const r of t.rooms.values())if(a(r.name)){const t=s.getFloorAtIndex(r.floorIndex);if(!t)throw new Error("Unable to find floor for room while generating search results.");n.push(new u(e.commandBinder,o,r,t.id))}return n.sort(((e,t)=>e.title.localeCompare(t.title)))},h=e=>{},g=e=>new a.V(t.onChanged(e)),f={renew:()=>{e.commandBinder.issueCommandWhenBound(new l.c6({id:d.SF.MODELROOM,groupPhraseKey:i.Z.TOOLS.ROOMPLAN,getSimpleMatches:r,registerChangeObserver:g,onSearchActivatedChanged:h,groupOrder:40,groupIcon:"icon-edit-floorplan"}))},cancel:()=>{e.commandBinder.issueCommandWhenBound(new l.Pe(d.SF.MODELROOM))}};return f.renew(),f}(t,this.data).then((e=>this.bindings.push(e)))}dispose(e){super.dispose(e)}}const $=D},56163:(e,t,o)=>{"use strict";o.d(t,{K:()=>n});var s=o(52528),a=o(71166),r=o(63319);const d=new s.v({});class n{constructor(e,t){this.commandBinder=e,this.layersData=t,this.enabled=!0,this.textParser=d,this.bindings=[]}getGroupingId(e){switch(e){case r.HH.TYPE:return this.getTypeId();case r.HH.FLOOR:return this.getFloorId();case r.HH.LAYER:return this.getLayerGroupId();case r.HH.DATE:return this.dateBucket}}getFloorId(){return this.floorId}getDateBucket(){return this.dateBucket}getTypeId(){return this.typeId}getLayerGroupId(){var e,t;const o=null===(e=this.layersData)||void 0===e?void 0:e.getBaseLayerId(),s=null===(t=this.layersData)||void 0===t?void 0:t.getViewLayerId();return this.layerId&&s&&this.layerId===o?s:this.layerId}isLayerVisible(){return!this.layersData||!this.layerId||this.layersData.layerVisible(this.layerId)}onSelect(){this.commandBinder.issueCommand(new a.IL(this.id,this.typeId))}registerBindings(){}cancelBindings(){this.bindings.forEach((e=>e.cancel()))}}}}]);